package github

import (
	"context"
	"fmt"
	"strings"
	"time"
)

// SecurityNotifier GitHub安全通知器
type SecurityNotifier struct {
	client   *Client
	enabled  bool
	template string
}

// LeakedKeyInfo 泄露密钥信息
type LeakedKeyInfo struct {
	KeyType     string    `json:"key_type"`
	Provider    string    `json:"provider"`
	Repository  string    `json:"repository"`
	FilePath    string    `json:"file_path"`
	URL         string    `json:"url"`
	KeyPreview  string    `json:"key_preview"`  // 只显示前10位
	DiscoveredAt time.Time `json:"discovered_at"`
	Severity    string    `json:"severity"`     // critical, high, medium
}

// IssueRequest GitHub issue创建请求
type IssueRequest struct {
	Title  string   `json:"title"`
	Body   string   `json:"body"`
	Labels []string `json:"labels"`
}

// NewSecurityNotifier 创建安全通知器
func NewSecurityNotifier(client *Client, enabled bool) *SecurityNotifier {
	template := `# 🚨 Security Alert: API Key Leaked

## Summary
A **{{ .Provider }}** API key has been detected in your repository, which poses a significant security risk.

## Details
- **Key Type**: {{ .KeyType }}
- **Provider**: {{ .Provider }}
- **File**: ` + "`{{ .FilePath }}`" + `
- **Repository**: {{ .Repository }}
- **Discovered**: {{ .DiscoveredAt.Format "2006-01-02 15:04:05" }}
- **Severity**: {{ .Severity }}

## Security Implications
Exposed API keys can lead to:
- ❌ Unauthorized access to your {{ .Provider }} account
- ❌ Potential data breaches and service abuse
- ❌ Unexpected charges and quota exhaustion
- ❌ Compliance violations and audit failures

## Immediate Actions Required

### 🔥 **URGENT** (Complete within 1 hour)
1. **Revoke the exposed key immediately**:
   - Go to your {{ .Provider }} dashboard
   - Find the API key: ` + "`{{ .KeyPreview }}...`" + `
   - Delete/revoke it immediately

2. **Generate a new key**:
   - Create a replacement API key
   - Update your application configuration
   - Test functionality with the new key

### 🛡️ **Secure Your Repository** (Complete within 24 hours)
1. **Remove from current files**:
   - Update ` + "`{{ .FilePath }}`" + ` to use environment variables
   - Never commit credentials directly to code

2. **Clean Git history**:
   ` + "```bash" + `
   # Remove from Git history (CAUTION: This rewrites history)
   git filter-branch --force --index-filter \
     'git rm --cached --ignore-unmatch {{ .FilePath }}' \
     --prune-empty --tag-name-filter cat -- --all
   ` + "```" + `

3. **Implement secure practices**:
   - Use ` + "`.env`" + ` files with ` + "`.gitignore`" + `
   - Use secret management services
   - Enable pre-commit hooks for secret detection

## Prevention Measures

### 📋 **Checklist for Future Security**
- [ ] Add ` + "`.env*`" + ` to ` + "`.gitignore`" + `
- [ ] Use environment variables for all secrets
- [ ] Install ` + "`gitleaks`" + ` or ` + "`trufflehog`" + ` for pre-commit scanning
- [ ] Regular security audits of your repositories
- [ ] Team training on secure coding practices

### 🔧 **Recommended Tools**
- ` + "`gitleaks`" + `: Scan for secrets in git repos
- ` + "`trufflehog`" + `: Find high entropy strings and secrets
- ` + "`git-secrets`" + `: Prevent secrets from being committed

## Resources
- [{{ .Provider }} Security Best Practices](#)
- [GitHub Secret Scanning Documentation](https://docs.github.com/en/code-security/secret-scanning)
- [OWASP Secrets Management Guide](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html)

---
**This issue was automatically generated by Kooix Hajimi Security Scanner**
**Discovered at**: {{ .URL }}
**Scanner Version**: 2.0
**Report ID**: {{ .Repository }}-{{ .DiscoveredAt.Unix }}`

	return &SecurityNotifier{
		client:   client,
		enabled:  enabled,
		template: template,
	}
}

// CreateSecurityIssue 创建安全问题issue
func (sn *SecurityNotifier) CreateSecurityIssue(ctx context.Context, keyInfo LeakedKeyInfo) error {
	if !sn.enabled {
		return nil
	}

	// 解析仓库信息
	repoOwner, repoName, err := parseRepositoryName(keyInfo.Repository)
	if err != nil {
		return fmt.Errorf("invalid repository format: %v", err)
	}

	// 生成issue内容
	title := fmt.Sprintf("🚨 Security Alert: %s API Key Exposed in %s", 
		keyInfo.Provider, keyInfo.FilePath)

	body := sn.renderTemplate(keyInfo)

	labels := []string{
		"security",
		"vulnerability", 
		"api-key-leak",
		fmt.Sprintf("provider-%s", strings.ToLower(keyInfo.Provider)),
		fmt.Sprintf("severity-%s", keyInfo.Severity),
	}

	// 创建issue请求
	issueReq := IssueRequest{
		Title:  title,
		Body:   body,
		Labels: labels,
	}

	// 发送到GitHub API
	url := fmt.Sprintf("https://api.github.com/repos/%s/%s/issues", repoOwner, repoName)
	
	// 获取token
	token := sn.client.tokens[int(sn.client.currentToken)%len(sn.client.tokens)]
	
	resp, err := sn.client.httpClient.R().
		SetContext(ctx).
		SetAuthToken(token).
		SetHeader("Accept", "application/vnd.github.v3+json").
		SetBody(issueReq).
		Post(url)
		
	if err != nil {
		return fmt.Errorf("failed to create issue: %v", err)
	}

	// 检查响应状态
	if resp.StatusCode() != 201 {
		return fmt.Errorf("failed to create issue, status: %d, body: %s", 
			resp.StatusCode(), resp.String())
	}

	return nil
}

// renderTemplate 渲染issue模板
func (sn *SecurityNotifier) renderTemplate(keyInfo LeakedKeyInfo) string {
	template := sn.template
	
	// 简单的模板替换
	replacements := map[string]string{
		"{{ .Provider }}":     keyInfo.Provider,
		"{{ .KeyType }}":      keyInfo.KeyType,
		"{{ .FilePath }}":     keyInfo.FilePath,
		"{{ .Repository }}":   keyInfo.Repository,
		"{{ .KeyPreview }}":   keyInfo.KeyPreview,
		"{{ .Severity }}":     keyInfo.Severity,
		"{{ .URL }}":          keyInfo.URL,
		"{{ .DiscoveredAt.Format \"2006-01-02 15:04:05\" }}": keyInfo.DiscoveredAt.Format("2006-01-02 15:04:05"),
		"{{ .DiscoveredAt.Unix }}": fmt.Sprintf("%d", keyInfo.DiscoveredAt.Unix()),
	}
	
	for placeholder, value := range replacements {
		template = strings.ReplaceAll(template, placeholder, value)
	}
	
	return template
}

// parseRepositoryName 解析仓库名称
func parseRepositoryName(fullName string) (owner, repo string, err error) {
	parts := strings.Split(fullName, "/")
	if len(parts) != 2 {
		return "", "", fmt.Errorf("invalid repository format: %s", fullName)
	}
	return parts[0], parts[1], nil
}